// Generated by CoffeeScript 1.3.3
var Color, ColorList, Context, Cube, Cylinder, DEFAULT_FA, DEFAULT_FN, DEFAULT_FS, Difference, Echo, GeometryBase, Intersection, Iterator, JsPassThrough, Mirror, MultMatrix, Objects, OpenSCADEvaluator, Polyhedron, RangeIterator, Render, Rotate, Scale, Sphere, Translate, Union, VectorIterator, prepare_multmatrix,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

DEFAULT_FA = 12;

DEFAULT_FS = 2;

DEFAULT_FN = 0;

Context = (function() {

  function Context(parent, current) {
    var _ref;
    this.parent = parent;
    this.current = current;
    if ((_ref = this.current) == null) {
      this.current = new Hash();
    }
    return;
  }

  Context.prototype.get = function(name) {
    var value;
    value = this.current.get(name);
    if ((value != null) && value !== false) {
      return value;
    }
    if (this.parent != null) {
      return this.parent.get(name);
    }
    throw "unknown name `" + name + "'";
  };

  Context.prototype.set = function(name, value) {
    this.current.set(name, value);
  };

  return Context;

})();

Iterator = (function() {

  function Iterator() {
    return;
  }

  Iterator.prototype.next = function() {
    throw 'not implemented';
  };

  return Iterator;

})();

RangeIterator = (function(_super) {

  __extends(RangeIterator, _super);

  function RangeIterator(start, increment, end) {
    this.start = start;
    this.increment = increment;
    this.end = end;
    return;
  }

  RangeIterator.prototype.toString = function() {
    return 'range(' + this.start + ':' + this.increment + ':' + this.end + ')';
  };

  RangeIterator.prototype.next = function() {
    if (!(this.current != null)) {
      this.current = this.start;
      return this.current;
    }
    this.current += this.increment;
    if (this.current > this.end) {
      this.current = void 0;
    }
    return this.current;
  };

  return RangeIterator;

})(Iterator);

VectorIterator = (function(_super) {

  __extends(VectorIterator, _super);

  function VectorIterator(values) {
    this.values = values;
    return;
  }

  VectorIterator.prototype.toString = function() {
    return 'vector([' + this.values + '])';
  };

  VectorIterator.prototype.size = function() {
    return this.values.length;
  };

  VectorIterator.prototype.next = function() {
    if (!(this.current != null)) {
      this.current = 0;
    } else {
      this.current += 1;
    }
    if (this.current >= this.values.length) {
      this.current = void 0;
    }
    return this.values[this.current];
  };

  return VectorIterator;

})(Iterator);

GeometryBase = (function() {
  " this class is a common base for all of the geometry classes ";

  function GeometryBase() {
    return;
  }

  GeometryBase.prototype.parseargs = function(args, kwargs) {
    "Match up arguments. \n\n@args contains a list of unnamed arguments.\n@kwargs contains a list of nammed arguments.\n@prototype contains a list of expected arguments\n\nWe expect @prototype to have all arguments without default value first, and the \nones with defaults last.\n\nWe first match up all arguments in @prototype with the unnamed arguments in @args in \nthe order they appear in @prototype, making sure none of them also appear in @kwargs.\nThen we match up the arguments in @kwargs which can appear in arbitrary order. If there\nare less arguments provided than expected in @prototype, default values are used.";

    var def, expected, i, name, ret, v, validnames, value, _i, _j, _len, _len1, _ref, _ref1;
    if ((args.length + kwargs.size()) > this.prototype.length) {
      throw 'too many arguments for function';
    }
    validnames = (function() {
      var _i, _len, _ref, _results;
      _ref = this.prototype;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        _results.push(v instanceof Array ? v[0] : v);
      }
      return _results;
    }).call(this);
    _ref = kwargs.keys();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      name = _ref[_i];
      if (__indexOf.call(validnames, name) < 0) {
        throw 'argument ' + name + ' is not a valid name for an argument of this function ' + validnames.join(', ');
      }
    }
    i = 0;
    ret = new Hash();
    _ref1 = this.prototype;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      expected = _ref1[_j];
      if (expected instanceof Array) {
        name = expected[0], def = expected[1];
      } else {
        name = expected;
        def = void 0;
      }
      if (i < args.length) {
        if (kwargs.get(name) != null) {
          throw 'argument ' + name + ' given implicitely as argument #' + i + ' but also specified by name';
        }
        ret.set(name, args[i]);
        i += 1;
      } else {
        value = kwargs.get(name);
        if (!(value != null)) {
          if (def === void 0) {
            throw 'argument ' + name + ' does not have a default value';
          }
          value = def;
        }
        ret.set(name, value);
      }
    }
    this.argshash = ret;
  };

  GeometryBase.prototype.formatargs = function() {
    var args, name, _i, _len, _ref;
    args = [];
    _ref = this.argshash.keys();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      name = _ref[_i];
      args.push(name + '=' + this.argshash.get(name));
    }
    return args.join(',');
  };

  return GeometryBase;

})();

Echo = (function(_super) {

  __extends(Echo, _super);

  " echo(`expr`) ";


  function Echo(body, args, kwargs) {
    this.args = args;
    if (body != null) {
      throw 'module cannot be instantiated with a body';
    }
    if (kwargs.size() > 0) {
      throw 'echo() cannot not take any named arguments';
    }
    return;
  }

  Echo.prototype.toString = function() {
    return 'echo(' + this.args.join(',') + ')';
  };

  return Echo;

})(GeometryBase);

ColorList = {
  lavander: [0, 0, 0]
};

Color = (function(_super) {

  __extends(Color, _super);

  "color([r, g, b, a])\ncolor(\"name\")";


  function Color(body, args, kwargs) {
    var _ref, _ref1, _ref2;
    this.body = body;
    this.prototype = ['color', ['alpha', null]];
    this.parseargs(args, kwargs);
    this.color = this.argshash.get('color');
    this.alpha = this.argshash.get('alpha');
    if (this.degree instanceof VectorIterator && !(typeof b !== "undefined" && b !== null)) {
      _ref = [1, this.degree], this.degree = _ref[0], this.vector = _ref[1];
    }
    if (!(this.vector != null)) {
      this.vector = new VectorIterator([0, 0, 1]);
    }
    if ((this.color instanceof VectorIterator) && this.alpha === null) {
      if ((_ref1 = this.color.size()) !== 3 && _ref1 !== 4) {
        throw "color() takes a 3-value or 4-value vector as argument (got: " + this.color.toString() + ")";
      }
      this.r = this.color.values[0];
      this.g = this.color.values[1];
      this.b = this.color.values[2];
      this.a = this.color.size() === 4 ? this.color.values[4] : 1;
    } else if (typeof this.color === "string") {
      if (ColorList[this.color] != null) {
        _ref2 = ColorList[this.color], this.r = _ref2[0], this.g = _ref2[1], this.b = _ref2[2];
      } else {
        throw "specified unknown color name as color() 1st parameter";
      }
    } else {
      throw "color() takes a vector or color name as argument";
    }
    this.x = this.vector.values[0];
    this.y = this.vector.values[1];
    this.z = this.vector.values[2];
    return;
  }

  Color.prototype.toString = function() {
    return 'color(' + this.formatargs() + '){' + this.body.toString() + '}';
  };

  return Color;

})(GeometryBase);

prepare_multmatrix = function(body, v) {
  var kwargs, m1, m2, m3, m4, matrix;
  m1 = new VectorIterator([v[0][0], v[0][1], v[0][2], v[0][3]]);
  m2 = new VectorIterator([v[1][0], v[1][1], v[1][2], v[1][3]]);
  m3 = new VectorIterator([v[2][0], v[2][1], v[2][2], v[2][3]]);
  m4 = new VectorIterator([v[3][0], v[3][1], v[3][2], v[3][3]]);
  matrix = new VectorIterator([m1, m2, m3, m4]);
  kwargs = new Hash({
    m: matrix
  });
  return new MultMatrix(body, [], kwargs);
};

Rotate = (function(_super) {

  __extends(Rotate, _super);

  "rotate(a = deg)\nrotate(a = deg, v = [x, y, z])\nrotate(a=[x_deg,y_deg,z_deg])";


  function Rotate(body, args, kwargs) {
    var parent, _ref;
    this.body = body;
    this.prototype = [['degree', null], ['vector', null], ['a', null]];
    this.parseargs(args, kwargs);
    this.degree = this.argshash.get('degree') || this.argshash.get('a');
    this.vector = this.argshash.get('vector');
    if (this.degree instanceof VectorIterator && !(typeof b !== "undefined" && b !== null)) {
      _ref = [1, this.degree], this.degree = _ref[0], this.vector = _ref[1];
    }
    if (!(this.vector != null)) {
      this.vector = new VectorIterator([0, 0, 1]);
    }
    if (!(this.vector instanceof VectorIterator) || this.vector.values.length !== 3) {
      throw "rotation() takes a 3-value vector as argument (got: " + this.vector.toString() + ")";
    }
    this.x = this.vector.values[0];
    this.x *= 0.0174532925;
    this.y = this.vector.values[1];
    this.y *= 0.0174532925;
    this.z = this.vector.values[2];
    this.z *= 0.0174532925;
    parent = this.body;
    if (this.x !== 0) {
      parent = prepare_multmatrix(parent, [[1, 0, 0, 0], [0, Math.cos(this.x), -Math.sin(this.x), 0], [0, Math.sin(this.x), Math.cos(this.x), 0], [0, 0, 0, 1]]);
    }
    if (this.y !== 0) {
      parent = prepare_multmatrix(parent, [[Math.cos(this.y), 0, Math.sin(this.y), 0], [0, 1, 0, 0], [-Math.sin(this.y), 0, Math.cos(this.y), 0], [0, 0, 0, 1]]);
    }
    if (this.z !== 0) {
      parent = prepare_multmatrix(parent, [[Math.cos(this.z), -Math.sin(this.z), 0, 0], [Math.sin(this.z), Math.cos(this.z), 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]);
    }
    return parent;
  }

  Rotate.prototype.toString = function() {
    return 'rotate(' + this.formatargs() + '){' + this.body.toString() + '}';
  };

  return Rotate;

})(GeometryBase);

Scale = (function(_super) {

  __extends(Scale, _super);

  "scale(v = [x, y, z])";


  function Scale(body, args, kwargs) {
    var m, vector;
    this.body = body;
    this.prototype = ['vector'];
    this.parseargs(args, kwargs);
    vector = this.argshash.get('vector');
    if (typeof vector === 'number') {
      this.vector = new VectorIterator([vector, vector, vector]);
    } else {
      this.vector = vector;
    }
    if (!(this.vector instanceof VectorIterator) || this.vector.values.length !== 3) {
      throw "scale() takes a 3-value vector as argument (got: " + vector.toString() + ")";
    }
    this.x = this.vector.values[0];
    this.y = this.vector.values[1];
    this.z = this.vector.values[2];
    m = this.body;
    if (this.x !== 0 || this.y !== 0 || this.z !== 0) {
      m = prepare_multmatrix(m, [[this.x, 0, 0, 0], [0, this.y, 0, 0], [0, 0, this.z, 0], [0, 0, 0, 1]]);
    }
    return m;
  }

  Scale.prototype.toString = function() {
    return 'scale(' + this.formatargs() + '){' + this.body.toString() + '}';
  };

  return Scale;

})(GeometryBase);

Mirror = (function(_super) {

  __extends(Mirror, _super);

  "mirror(v = [x, y, z])";


  function Mirror(body, args, kwargs) {
    var m;
    this.body = body;
    this.prototype = ['vector'];
    this.parseargs(args, kwargs);
    this.vector = this.argshash.get('vector');
    if (!(this.vector instanceof VectorIterator) || this.vector.values.length !== 3) {
      throw "mirror() takes a 3-value vector as argument (got: " + this.vector.toString() + ")";
    }
    this.x = this.vector.values[0];
    this.y = this.vector.values[1];
    this.z = this.vector.values[2];
    m = this.body;
    if (this.x !== 0 || this.y !== 0 || this.z !== 0) {
      m = prepare_multmatrix(m, [[(this.x !== 0 ? -1 : 1), 0, 0, 0], [0, (this.y !== 0 ? -1 : 1), 0, 0], [0, 0, (this.z !== 0 ? -1 : 1), 0], [0, 0, 0, 1]]);
    }
    return m;
  }

  Mirror.prototype.toString = function() {
    return 'mirror(' + this.formatargs() + '){' + this.body.toString() + '}';
  };

  return Mirror;

})(GeometryBase);

Translate = (function(_super) {

  __extends(Translate, _super);

  function Translate(body, args, kwargs) {
    var m;
    this.body = body;
    this.prototype = [['v', null], ['convexity', null]];
    this.parseargs(args, kwargs);
    this.convexity = this.argshash.get('convexity') || this.argshash.get('v');
    if (!(this.convexity instanceof VectorIterator) || this.convexity.values.length !== 3) {
      throw "parameter `convexity' of translate() should evaluate to a 3-value vector or a number (got: " + this.convexity.toString() + ")";
    }
    this.x = this.convexity.values[0];
    this.y = this.convexity.values[1];
    this.z = this.convexity.values[2];
    m = this.body;
    if (this.x !== 0 || this.y !== 0 || this.z !== 0) {
      m = prepare_multmatrix(m, [[1, 0, 0, this.x], [0, 1, 0, this.y], [0, 0, 1, this.z], [0, 0, 0, 1]]);
    }
    return m;
  }

  Translate.prototype.toString = function() {
    return 'translate(' + this.formatargs() + '){' + this.body.toString() + '}';
  };

  return Translate;

})(GeometryBase);

MultMatrix = (function(_super) {

  __extends(MultMatrix, _super);

  "multmatrix([[a1, b1, c1, d1], [a2, b2, c2, d2], [a3, b3, c3, d3], [a4, b4, c4, d4]])";


  function MultMatrix(body, args, kwargs) {
    this.body = body;
    if ((this.body != null) && this.body.constructor.name === 'Objects') {
      this.body = new Union(this.body);
    }
    this.prototype = ['m'];
    this.parseargs(args, kwargs);
    this.matrix = this.argshash.get('m');
    if (!(this.matrix instanceof VectorIterator) || this.matrix.size() !== 4) {
      throw "multmatrix() takes a 4x4 matrix as argument";
    }
    this.n1 = this.matrix.values[0];
    this.n2 = this.matrix.values[1];
    this.n3 = this.matrix.values[2];
    this.n4 = this.matrix.values[3];
    if (!(this.n1 instanceof VectorIterator) || this.n1.size() !== 4) {
      throw "multmatrix() takes a 4x4 matrix as argument";
    }
    if (!(this.n2 instanceof VectorIterator) || this.n2.size() !== 4) {
      throw "multmatrix() takes a 4x4 matrix as argument";
    }
    if (!(this.n3 instanceof VectorIterator) || this.n3.size() !== 4) {
      throw "multmatrix() takes a 4x4 matrix as argument";
    }
    if (!(this.n4 instanceof VectorIterator) || this.n4.size() !== 4) {
      throw "multmatrix() takes a 4x4 matrix as argument";
    }
    this.n11 = this.n1.values[0];
    this.n12 = this.n1.values[1];
    this.n13 = this.n1.values[2];
    this.n14 = this.n1.values[3];
    this.n21 = this.n2.values[0];
    this.n22 = this.n2.values[1];
    this.n23 = this.n2.values[2];
    this.n24 = this.n2.values[3];
    this.n31 = this.n3.values[0];
    this.n32 = this.n3.values[1];
    this.n33 = this.n3.values[2];
    this.n34 = this.n3.values[3];
    this.n41 = this.n4.values[0];
    this.n42 = this.n4.values[1];
    this.n43 = this.n4.values[2];
    this.n44 = this.n4.values[3];
    return;
  }

  MultMatrix.prototype.toString = function() {
    return 'multmatrix(' + this.formatargs() + '){' + this.body.toString() + '}';
  };

  return MultMatrix;

})(GeometryBase);

Difference = (function(_super) {

  __extends(Difference, _super);

  function Difference(body) {
    this.body = body;
    return;
  }

  Difference.prototype.toString = function() {
    return 'difference(){' + this.body.toString() + '}';
  };

  return Difference;

})(GeometryBase);

Union = (function(_super) {

  __extends(Union, _super);

  function Union(body) {
    this.body = body;
    return;
  }

  Union.prototype.toString = function() {
    return 'union(){' + this.body.toString() + '}';
  };

  return Union;

})(GeometryBase);

Intersection = (function(_super) {

  __extends(Intersection, _super);

  function Intersection(body) {
    this.body = body;
    return;
  }

  Intersection.prototype.toString = function() {
    return 'intersection(){' + this.body.toString() + '}';
  };

  return Intersection;

})(GeometryBase);

Objects = (function(_super) {

  __extends(Objects, _super);

  function Objects(objects) {
    var _ref;
    this.objects = objects;
    if ((_ref = this.objects) == null) {
      this.objects = [];
    }
    return;
  }

  Objects.prototype.toString = function() {
    var obj;
    return ((function() {
      var _i, _len, _ref, _results;
      _ref = this.objects;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        obj = _ref[_i];
        _results.push(obj.toString());
      }
      return _results;
    }).call(this)).join(',');
  };

  return Objects;

})(GeometryBase);

Render = (function(_super) {

  __extends(Render, _super);

  function Render(body, args, kwargs) {
    this.body = body;
    this.prototype = ['convexity'];
    this.parseargs(args, kwargs);
    this.convexity = this.argshash['convexity'];
    return;
  }

  Render.prototype.toString = function() {
    return 'render(' + this.formatargs() + '){' + this.body.toString() + '}';
  };

  return Render;

})(GeometryBase);

Polyhedron = (function(_super) {

  __extends(Polyhedron, _super);

  function Polyhedron(body, args, kwargs) {
    if (body != null) {
      throw 'module cannot be instantiated with a body';
    }
    this.prototype = ['points', 'triangles'];
    this.parseargs(args, kwargs);
    this.points = this.argshash.get('points');
    this.triangles = this.argshash.get('triangles');
    return;
  }

  Polyhedron.prototype.toString = function() {
    return 'polyhedron(' + this.formatargs() + ')';
  };

  return Polyhedron;

})(GeometryBase);

Sphere = (function(_super) {

  __extends(Sphere, _super);

  function Sphere(body, args, kwargs) {
    if (body != null) {
      throw 'module cannot be instantiated with a body';
    }
    this.prototype = ['r', ['$fa', DEFAULT_FA], ['$fs', DEFAULT_FS], ['$fn', DEFAULT_FN]];
    this.parseargs(args, kwargs);
    this.r = this.argshash.get('r');
    this.center = this.argshash.get('center');
    return;
  }

  Sphere.prototype.toString = function() {
    return 'sphere(' + this.formatargs() + ')';
  };

  return Sphere;

})(GeometryBase);

Cylinder = (function(_super) {

  __extends(Cylinder, _super);

  function Cylinder(body, args, kwargs) {
    var r;
    if (body != null) {
      throw 'module cannot be instantiated with a body';
    }
    this.prototype = [['h', 1], ['r', null], ['r1', null], ['r2', null], ['center', false], ['$fn', DEFAULT_FN], ['$fa', DEFAULT_FA], ['$fs', DEFAULT_FS]];
    this.parseargs(args, kwargs);
    this.height = this.argshash.get('h');
    r = this.argshash.get('r');
    if (r !== null) {
      this.r1 = r;
      this.r2 = r;
    } else {
      this.r1 = this.argshash.get('r1');
      this.r2 = this.argshash.get('r2');
      if (this.r1 === null && this.r2 === null) {
        this.r1 = 1;
        this.r2 = 1;
      } else if (this.r1 === null || this.r2 === null) {
        throw 'either "r" or "r1"/"r2" must be specified for cylinder()';
      }
    }
    this.center = this.argshash.get('center');
    return;
  }

  Cylinder.prototype.toString = function() {
    return 'cylinder(' + this.formatargs() + ')';
  };

  return Cylinder;

})(GeometryBase);

Cube = (function(_super) {

  __extends(Cube, _super);

  function Cube(body, args, kwargs) {
    if (body != null) {
      throw 'module cannot be instantiated with a body';
    }
    this.prototype = ['size', ['center', false]];
    this.parseargs(args, kwargs);
    this.size = this.argshash.get('size');
    if (typeof this.size === 'number') {
      this.x = this.size;
      this.y = this.size;
      this.z = this.size;
    } else if (this.size instanceof VectorIterator && this.size.values.length === 3) {
      this.x = this.size.values[0];
      this.y = this.size.values[1];
      this.z = this.size.values[2];
    } else {
      throw "parameter `size' of cube() should evaluate to a 3-value vector or a number (got: " + this.size.toString() + ")";
    }
    this.center = this.argshash.get('center');
    return;
  }

  Cube.prototype.toString = function() {
    return 'cube(' + this.formatargs() + ')';
  };

  return Cube;

})(GeometryBase);

JsPassThrough = (function() {

  function JsPassThrough(fct) {
    this.fct = fct;
    return;
  }

  JsPassThrough.prototype.passthrough = function(self, args) {
    return this.fct.apply(self, args);
  };

  return JsPassThrough;

})();

OpenSCADEvaluator = (function() {
  " this class walks through the language representation and builds the geometry representation ";

  function OpenSCADEvaluator(root_node) {
    this.root_node = root_node;
    return;
  }

  OpenSCADEvaluator.prototype.evaluate = function(ctx) {
    return this.walk(ctx, this.root_node);
  };

  OpenSCADEvaluator.prototype.register_builtins = function(ctx) {
    " register the built-in modules in the current scope. ";

    var _this = this;
    ctx.set('echo', Echo);
    ctx.set('str', new JsPassThrough(function() {
      var arg;
      return ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = arguments.length; _i < _len; _i++) {
          arg = arguments[_i];
          _results.push(arg.toString());
        }
        return _results;
      }).apply(this, arguments)).join('');
    }));
    ctx.set('sign', new JsPassThrough(function(n) {
      if (n > 1) {
        return 1.0;
      }
      if (n < 1) {
        return -1.0;
      }
      return 0;
    }));
    ctx.set('abs', new JsPassThrough(function(n) {
      return Math.abs(n * Math.PI / 180);
    }));
    ctx.set('acos', new JsPassThrough(function(n) {
      return Math.acos(n * Math.PI / 180);
    }));
    ctx.set('asin', new JsPassThrough(function(n) {
      return Math.asin(n * Math.PI / 180);
    }));
    ctx.set('atan', new JsPassThrough(function(n) {
      return Math.atan(n * Math.PI / 180);
    }));
    ctx.set('atan2', new JsPassThrough(function(n) {
      return Math.atan2(n * Math.PI / 180);
    }));
    ctx.set('ceil', new JsPassThrough(Math.ceil));
    ctx.set('cos', new JsPassThrough(function(n) {
      return Math.cos(n * Math.PI / 180);
    }));
    ctx.set('exp', new JsPassThrough(Math.exp));
    ctx.set('floor', new JsPassThrough(Math.floor));
    ctx.set('ln', new JsPassThrough(Math.log));
    ctx.set('len', new JsPassThrough(function(obj) {
      if (obj instanceof VectorIterator) {
        return obj.values.length;
      }
      if (typeof obj === 'string') {
        return obj.length;
      }
      throw 'cannot get length of this object type';
    }));
    ctx.set('max', new JsPassThrough(Math.max));
    ctx.set('min', new JsPassThrough(Math.min));
    ctx.set('pow', new JsPassThrough(Math.pow));
    ctx.set('sin', new JsPassThrough(function(n) {
      return Math.sin(n * Math.PI / 180);
    }));
    ctx.set('sqrt', new JsPassThrough(Math.sqrt));
    ctx.set('tan', new JsPassThrough(Math.tan));
    ctx.set('rands', new JsPassThrough(function(min_value, max_value, value_count, seed_value) {
      var i;
      return new VectorIterator((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= value_count ? _i <= value_count : _i >= value_count; i = 0 <= value_count ? ++_i : --_i) {
          _results.push((Math.random() * (max_value - min_value)) + min_value);
        }
        return _results;
      })());
    }));
    ctx.set('round', new JsPassThrough(Math.round));
    ctx.set('union', Union);
    ctx.set('difference', Difference);
    ctx.set('intersection', Intersection);
    ctx.set('rotate', Rotate);
    ctx.set('translate', Translate);
    ctx.set('scale', Scale);
    ctx.set('multmatrix', MultMatrix);
    ctx.set('mirror', Mirror);
    ctx.set('color', Color);
    ctx.set('render', Render);
    ctx.set('polyhedron', Polyhedron);
    ctx.set('cube', Cube);
    ctx.set('sphere', Sphere);
    return ctx.set('cylinder', Cylinder);
  };

  OpenSCADEvaluator.prototype.walk = function(ctx, node) {
    var arg, args, b, body, condition, ctor, defaultvalue, expr, fct, id, idx, iterator, k, kwargs, m, name, new_ctx, nodetype, obj, objects, pargs, pkwargs, ret, v, value, variable, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref10, _ref11, _ref12, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    if (!(node != null)) {
      return;
    }
    nodetype = node.constructor.name;
    switch (nodetype) {
      case "Include":
        " call the 'include' function to get new nodes. ";

        fct = ctx.get('include');
        if (!(fct != null)) {
          throw '"include" is not defined in this context';
        }
        node = fct(node.name);
        this.walk(ctx, node);
        return;
      case "Use":
        " call the 'use' function to get new nodes. ";

        fct = ctx.get('use');
        if (!(fct != null)) {
          throw '"include" is not defined in this context';
        }
        node = fct(node.name);
        this.walk(ctx, node);
        return;
      case "Assignment":
        " set the proper value in the current context. ";

        id = node.identifier.name;
        expr = this.walk(ctx, node.expression);
        ctx.set(id, expr);
        return;
      case "ModuleDefinition":
      case "FunctionDefinition":
        " store the node itself in the context to delegate its instanciation to whenever it is actually used ";

        id = node.identifier.name;
        ctx.set(id, node);
        return;
      case "Assign":
        " introduce the variables in the current context and continue evaluating the sub-blocks ";

        _ref = this.walk(ctx, node["arguments"]), args = _ref[0], kwargs = _ref[1];
        if (args.length > 0) {
          throw 'assign() cannot make use of unnamed arguments';
        }
        new_ctx = new Context(ctx, kwargs);
        objects = [];
        obj = this.walk(new_ctx, node.body);
        if (!(obj != null)) {
          return;
        }
        if (obj instanceof Array) {
          objects = objects.concat(obj);
        } else {
          objects.push(obj);
        }
        if (objects.length === 0) {
          return;
        }
        if (objects.length === 1) {
          return objects[0];
        }
        ret = new Union(new Objects(objects));
        return ret;
      case "For":
      case "IntersectionFor":
        " unroll the loop and return the resulting list of objects ";

        id = this.walk(ctx, node.identifier);
        _ref1 = this.walk(ctx, node["arguments"]), variable = _ref1[0], iterator = _ref1[1];
        if (!(iterator instanceof Iterator)) {
          throw 'for() loops take range or vector as argument (got ' + iterator + ')';
        }
        new_ctx = new Context(ctx);
        objects = [];
        while ((value = iterator.next()) !== void 0) {
          new_ctx.set(variable, value);
          obj = this.walk(new_ctx, node.body);
          if (!(obj != null)) {
            continue;
          }
          if (obj instanceof Array) {
            objects = objects.concat(obj);
          } else {
            objects.push(obj);
          }
        }
        ret = new Objects(objects);
        if (nodetype === 'IntersectionFor') {
          ret = new Intersection(ret);
        } else {
          ret = new Union(ret);
        }
        return ret;
      case "IfElseStatement":
        condition = this.walk(ctx, node.condition);
        if (condition) {
          return this.walk(ctx, node.body);
        } else if (node.else_body != null) {
          return this.walk(ctx, node.else_body);
        }
        return;
      case "ModuleBody":
      case "CurlyBraces":
        " the ModuleBody is implicitly a union, whereas CurlyBraces only imply a list of objects\n\nFor proper scoping, we need to first evaluate any module, functions and assignments and\ninsert those in the current context. Then we can process other statements.";

        _ref2 = node.children;
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          expr = _ref2[_i];
          if ((_ref3 = expr.constructor.name) === 'ModuleDefinition' || _ref3 === 'FunctionDefinition' || _ref3 === 'Assignment') {
            this.walk(ctx, expr);
          }
        }
        objects = [];
        _ref4 = node.children;
        for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
          expr = _ref4[_j];
          if ((_ref5 = expr.constructor.name) === 'ModuleDefinition' || _ref5 === 'FunctionDefinition' || _ref5 === 'Assignment') {
            continue;
          }
          obj = this.walk(ctx, expr);
          if (!(obj != null)) {
            continue;
          }
          if (obj instanceof Array) {
            objects = objects.concat(obj);
          } else {
            objects.push(obj);
          }
        }
        if (objects.length === 0) {
          return void 0;
        }
        if (objects.length === 1) {
          return objects[0];
        }
        ret = new Objects(objects);
        if (nodetype === 'ModuleBody') {
          ret = new Union(ret);
        }
        return ret;
      case "ModuleInstantiation":
        " there are two types of instantiations: the first type is all the built-in \nfunctions, the other type are the user-declared modules and functions.";

        ctor = this.walk(ctx, node.identifier);
        if (!(ctor != null)) {
          throw 'module or function "' + node.identifier.name + '" is not declared in this scope';
        }
        if ((_ref6 = ctor.constructor.name) === 'ModuleDefinition' || _ref6 === 'FunctionDefinition') {
          " the constructor is a module or function definition that is not yet evaluated ";

          b = new GeometryBase();
          if (ctor["arguments"] != null) {
            _ref7 = this.walk(ctx, ctor["arguments"]), pargs = _ref7[0], pkwargs = _ref7[1];
            b.prototype = pargs.concat((function() {
              var _k, _len2, _ref8, _results;
              _ref8 = pkwargs.keys();
              _results = [];
              for (_k = 0, _len2 = _ref8.length; _k < _len2; _k++) {
                name = _ref8[_k];
                _results.push([name, pkwargs.get(name)]);
              }
              return _results;
            })());
          } else {
            b.prototype = [];
          }
          _ref8 = this.walk(ctx, node["arguments"]), args = _ref8[0], kwargs = _ref8[1];
          b.parseargs(args, kwargs);
          new_ctx = new Context(ctx, b.argshash);
          m = this.walk(new_ctx, ctor.body);
          if (ctor.constructor.name === 'ModuleDefinition' && m.constructor.name === 'Objects') {
            m = new Union(m);
          }
        } else {
          " the constructor is one of our built-in geometry objects ";

          if (ctor instanceof JsPassThrough) {
            if (node.body != null) {
              throw 'cannot instanciate ' + ctor.toString() + ' with a body';
            }
            _ref9 = this.walk(ctx, node["arguments"]), args = _ref9[0], kwargs = _ref9[1];
            if (kwargs.size() > 0) {
              throw 'cannot use named arguments with function ' + ctor.toString();
            }
            m = ctor.passthrough(this, args);
          } else {
            _ref10 = this.walk(ctx, node["arguments"]), args = _ref10[0], kwargs = _ref10[1];
            if (node.body != null) {
              body = this.walk(ctx, node.body);
            }
            m = new ctor(body, args, kwargs);
          }
        }
        return m;
      case "Identifier":
        return ctx.get(node.name);
      case "Dereference":
        return this.dereference(ctx, this.walk(ctx, node.expression), this.walk(ctx, node.identifier));
      case "Range":
        return new RangeIterator(this.walk(ctx, node.start), (node.increment != null ? this.walk(ctx, node.increment) : 1), this.walk(ctx, node.end));
      case "Vector":
        return new VectorIterator((function() {
          var _k, _len2, _ref11, _results;
          _ref11 = node.children;
          _results = [];
          for (_k = 0, _len2 = _ref11.length; _k < _len2; _k++) {
            value = _ref11[_k];
            _results.push(this.walk(ctx, value));
          }
          return _results;
        }).call(this));
      case "Expression":
        return node.value;
      case "Multiply":
        return this.walk(ctx, node.left) * this.walk(ctx, node.right);
      case "Divide":
        return this.walk(ctx, node.left) / this.walk(ctx, node.right);
      case "Modulo":
        return this.walk(ctx, node.left) % this.walk(ctx, node.right);
      case "Plus":
        return this.walk(ctx, node.left) + this.walk(ctx, node.right);
      case "Minus":
        return this.walk(ctx, node.left) - this.walk(ctx, node.right);
      case "LessThan":
        return this.walk(ctx, node.left) < this.walk(ctx, node.right);
      case "LowerEqual":
        return this.walk(ctx, node.left) <= this.walk(ctx, node.right);
      case "Equal":
        return this.walk(ctx, node.left) === this.walk(ctx, node.right);
      case "NotEqual":
        return this.walk(ctx, node.left) !== this.walk(ctx, node.right);
      case "GreaterEqual":
        return this.walk(ctx, node.left) >= this.walk(ctx, node.right);
      case "MoreThan":
        return this.walk(ctx, node.left) > this.walk(ctx, node.right);
      case "And":
        return this.walk(ctx, node.left) && this.walk(ctx, node.right);
      case "Or":
        return this.walk(ctx, node.left) || this.walk(ctx, node.right);
      case "Negate":
        return !this.walk(ctx, node.expression);
      case "UnaryMinus":
        return -this.walk(ctx, node.expression);
      case "TernaryIf":
        return (this.walk(ctx, node.condition) ? this.walk(ctx, node.true_expression) : this.walk(ctx, node.false_expression));
      case "Index":
        idx = this.walk(ctx, node.index);
        expr = this.walk(ctx, node.expression);
        if (expr instanceof VectorIterator) {
          ret = expr.values[idx];
        } else if (typeof expr === 'string') {
          ret = expr[idx];
        } else {
          throw 'cannot index this type of object';
        }
        return ret;
      case "ArgumentList":
        " An argument list can either be used in the context of a prototype declaration (module, function) or \nin the context of a function call (aka module instantiation). ";

        args = [];
        kwargs = new Hash();
        _ref11 = node.args;
        for (_k = 0, _len2 = _ref11.length; _k < _len2; _k++) {
          arg = _ref11[_k];
          _ref12 = this.walk(ctx, arg), k = _ref12[0], v = _ref12[1];
          if (k != null) {
            kwargs.set(k, v);
          } else {
            args.push(v);
          }
        }
        return [args, kwargs];
      case "ArgumentDeclaration":
        defaultvalue = this.walk(ctx, node.defaultvalue);
        return [node.identifier.name, defaultvalue];
      case "CallArgument":
        return [(node.identifier != null ? node.identifier.name : void 0), this.walk(ctx, node.value)];
      default:
        throw 'unknown language construct: ' + node.constructor.name;
    }
  };

  return OpenSCADEvaluator;

})();
